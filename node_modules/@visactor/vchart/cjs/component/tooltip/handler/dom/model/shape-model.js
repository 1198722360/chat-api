"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ShapeModel = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), base_tooltip_model_1 = require("./base-tooltip-model"), util_1 = require("../util");

class ShapeModel extends base_tooltip_model_1.BaseTooltipModel {
    init(classList, id, tag) {
        if (!this.product) {
            const container = this.createElement(null != tag ? tag : "div", [ ...null != classList ? classList : [], "shape" ], void 0, id);
            this.product = container;
        }
    }
    setStyle(style, option) {
        super.setStyle(style), this.setSvg(option);
    }
    setContent(option) {
        this.setSvg(option);
    }
    setSvg(option) {
        const html = getSvgHtml(option, this._option.valueToHtml);
        this.product && html !== this._svgHtmlCache && (this._svgHtmlCache = html, this.product.innerHTML = html);
    }
    release() {
        super.release(), this._svgHtmlCache = "";
    }
}

function getSvgHtml(option, valueToHtml) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!(null == option ? void 0 : option.hasShape) || !option.symbolType) return "";
    const {symbolType: symbolType, fill: fill, stroke: stroke, hollow: hollow = !1} = option, size = option.size ? valueToHtml(option.size) : "8px", marginTop = option.marginTop ? valueToHtml(option.marginTop) : "0px", lineWidth = option.lineWidth ? valueToHtml(option.lineWidth) + "px" : "0px";
    let fillString = "currentColor";
    const getStroke = () => stroke ? valueToHtml(stroke) : fillString, symbol = new vrender_core_1.Symbol({
        symbolType: symbolType,
        size: (0, util_1.pixelPropertyStrToNumber)(size),
        fill: !0
    }), pathModel = null !== (_a = symbol.getParsedPath().path) && void 0 !== _a ? _a : symbol.getParsedPath().pathStr, path = pathModel.toString();
    let viewBox = "-0.5 -0.5 1 1";
    if (!(0, vutils_1.isString)(pathModel)) {
        const bounds = pathModel.bounds;
        viewBox = `${bounds.x1} ${bounds.y1} ${bounds.width()} ${bounds.height()}`;
    }
    if ("0px" !== lineWidth) {
        const [x, y, w, h] = viewBox.split(" ").map((n => Number(n))), lw = Number(lineWidth.slice(0, -2));
        viewBox = `${x - lw / 2} ${y - lw / 2} ${w + lw} ${h + lw}`;
    }
    if (!fill || (0, vutils_1.isString)(fill) || hollow) return fillString = hollow ? "none" : fill ? valueToHtml(fill) : "currentColor", 
    `\n    <svg width="${size}" height="${size}" viewBox="${viewBox}"\n      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">\n      <path\n        d="${path}"\n        style="fill: ${fillString}; stroke: ${getStroke()}; stroke-width: ${lineWidth}"\n      >\n      </path>\n    </svg>`;
    if ((0, vutils_1.isObject)(fill)) {
        fillString = null !== (_b = "gradientColor" + option.index) && void 0 !== _b ? _b : "";
        let gradient = "";
        const stops = (null !== (_c = fill.stops) && void 0 !== _c ? _c : []).map((s => `<stop offset="${valueToHtml(s.offset.toString())}" stop-color="${valueToHtml(s.color)}"/>`)).join("");
        return "radial" === fill.gradient ? gradient = `<radialGradient id="${fillString}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">\n      ${stops}\n      </radialGradient>` : "linear" === fill.gradient && (gradient = `<linearGradient id="${fillString}" x1="${100 * (null !== (_d = fill.x0) && void 0 !== _d ? _d : 0)}%" y1="${100 * (null !== (_e = fill.y0) && void 0 !== _e ? _e : 0)}%" x2="${100 * (null !== (_f = fill.x1) && void 0 !== _f ? _f : 0)}%" y2="${100 * (null !== (_g = fill.y1) && void 0 !== _g ? _g : 0)}%">\n      ${stops}\n      </linearGradient>`), 
        `\n    <svg width="${size}" height="${size}" viewBox="-0.5 -0.5 1 1"\n      style="display: inline-block; vertical-align: middle; margin-top: ${marginTop};">\n      ${gradient}\n      <path\n        d="${path}"\n        style="fill: url(#${fillString}); stroke: ${getStroke()}; stroke-width: ${lineWidth}"\n      >\n      </path>\n    </svg>`;
    }
    return "";
}

exports.ShapeModel = ShapeModel;
//# sourceMappingURL=shape-model.js.map
